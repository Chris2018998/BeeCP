/*
 * Copyright(C) Chris2018998
 * Contact:Chris2018998@tom.com
 *
 * Licensed under GNU Lesser General Public License v2.1
 */
package cn.beecp;

import cn.beecp.pool.ConnectionFactoryByDriver;
import cn.beecp.pool.ConnectionFactoryByDs;
import cn.beecp.pool.XaConnectionFactoryByDs;

import javax.sql.DataSource;
import javax.sql.XADataSource;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicInteger;

import static cn.beecp.TransactionIsolationLevel.TRANS_LEVEL_CODE_LIST;
import static cn.beecp.pool.PoolStaticCenter.*;
import static java.util.concurrent.TimeUnit.MINUTES;
import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * Connection pool configuration under dataSource
 *
 * @author Chris.Liao
 * @version 1.0
 */
public class BeeDataSourceConfig implements BeeDataSourceConfigJmxBean {
    //the number of CPUs
    private static final int NCPUS = Runtime.getRuntime().availableProcessors();
    //poolName index
    private static final AtomicInteger PoolNameIndex = new AtomicInteger(1);

    //extra properties for jdbc driver to connect db
    private final Map<String, Object> connectProperties = new HashMap<String, Object>(1);
    //jdbc user name
    private String username;
    //jdbc password
    private String password;
    //jdbc link url
    private String jdbcUrl;
    //jdbc driver class name
    private String driverClassName;
    //pool name,if not set,auto generated by<code>BeeDataSourceConfig.PoolNameIndex</code>
    private String poolName;
    //boolean indicator,true:pool use fair semaphore and fair transfer policy,default value:false
    private boolean fairMode;
    //connections create size on pool starting
    private int initialSize;
    //connections max reachable size in pool
    private int maxActive = Math.min(Math.max(10, NCPUS), 50);
    //max permit size of pool semaphore
    private int borrowSemaphoreSize = Math.min(maxActive / 2, NCPUS);
    //milliseconds:max wait time to get one connection from pool<code>ConnectionPool.getConnection()</code>
    private long maxWait = SECONDS.toMillis(8);
    //milliseconds:max idle time of connections in pool,when reach,then close them and remove from pool
    private long idleTimeout = MINUTES.toMillis(3);
    //milliseconds:max no-use time hold by borrowers,when reach,then return them to pool by forced close
    private long holdTimeout = MINUTES.toMillis(3);
    //connection valid test sql on borrowed
    private String validTestSql = "SELECT 1";
    //seconds:max time to get valid test result
    private int validTestTimeout = 3;
    //milliseconds:max gap time between last activity and borrowed,if less this value,assume connection valid,otherwise test them
    private long validAssumeTime = 500L;
    //milliseconds:interval time of pool idle-scan timer task
    private long timerCheckInterval = MINUTES.toMillis(3);
    //close indicator of connections in using on pool clean
    private boolean forceCloseUsingOnClear;
    //milliseconds:delay time for next clear using connections util them return to pool,when<config>forceCloseUsingOnClear</config> is false
    private long delayTimeForNextClear = 3000L;


    //connection default value:catalog <code>Connection.setAutoCommit(String)</code>
    private String defaultCatalog;
    //connection default value:schema <code>Connection.setSchema(String)</code>
    private String defaultSchema;
    //connection default value:readOnly <code>Connection.setReadOnly(boolean)</code>
    private Boolean defaultReadOnly;
    //connection default value:autoCommit <code>Connection.setAutoCommit(boolean)</code>
    private Boolean defaultAutoCommit;
    //connection default value:transactionIsolation <code>Connection.setTransactionIsolation(int)</code>
    private Integer defaultTransactionIsolationCode;
    //connection default value:description of transactionIsolation <code>defaultTransactionIsolationCode</code>
    private String defaultTransactionIsolationName;
    /**
     * connection factory class,which is one implementation class of
     * 1:<class>RawConnectionFactory</class>
     * 2:<class>RawXaConnectionFactory</class>
     * 3:<class>DataSource</class>
     * 4:<class>XADataSource</class>
     */
    private Class connectionFactoryClass;
    //connection factory class name
    private String connectionFactoryClassName;
    //connection factory
    private Object connectionFactory;
    //password decoder
    private Class passwordDecoderClass;
    //password decoder class name
    private String passwordDecoderClassName;
    //pool implementation class name
    private String poolImplementClassName;
    //jmx register indicator
    private boolean enableJmx;
    //config print indicator on pool starting
    private boolean printConfigInfo;
    //runtime log print indicator on pool activity
    private boolean printRuntimeLog;

    //***************************************************************************************************************//
    //                                     1: constructors(4)                                                        //
    //***************************************************************************************************************//
    public BeeDataSourceConfig() {
    }

    //read configuration from properties file
    public BeeDataSourceConfig(File propertiesFile) {
        this.loadFromPropertiesFile(propertiesFile);
    }

    //read configuration from properties file
    public BeeDataSourceConfig(String propertiesFileName) {
        this.loadFromPropertiesFile(propertiesFileName);
    }

    //read configuration from properties
    public BeeDataSourceConfig(Properties configProperties) {
        this.loadFromProperties(configProperties);
    }

    public BeeDataSourceConfig(String driver, String url, String user, String password) {
        this.jdbcUrl = trimString(url);
        this.username = trimString(user);
        this.password = trimString(password);
        this.driverClassName = trimString(driver);
    }

    //***************************************************************************************************************//
    //                                     2: JDBC link configuration methods(10)                                    //
    //***************************************************************************************************************//
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = trimString(username);
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = trimString(password);
    }

    public String getUrl() {
        return jdbcUrl;
    }

    public void setUrl(String jdbcUrl) {
        this.jdbcUrl = trimString(jdbcUrl);
    }

    public String getJdbcUrl() {
        return jdbcUrl;
    }

    public void setJdbcUrl(String jdbcUrl) {
        this.jdbcUrl = trimString(jdbcUrl);
    }

    public String getDriverClassName() {
        return driverClassName;
    }

    public void setDriverClassName(String driverClassName) {
        this.driverClassName = trimString(driverClassName);
    }


    //***************************************************************************************************************//
    //                                3: configuration about pool inner control(29)                                  //
    //***************************************************************************************************************//
    public String getPoolName() {
        return poolName;
    }

    public void setPoolName(String poolName) {
        this.poolName = trimString(poolName);
    }

    public boolean isFairMode() {
        return fairMode;
    }

    public void setFairMode(boolean fairMode) {
        this.fairMode = fairMode;
    }

    public int getInitialSize() {
        return initialSize;
    }

    public void setInitialSize(int initialSize) {
        if (initialSize >= 0) this.initialSize = initialSize;
    }

    public int getMaxActive() {
        return maxActive;
    }

    public void setMaxActive(int maxActive) {
        if (maxActive > 0) {
            this.maxActive = maxActive;
            //fix issue:#19 Chris-2020-08-16 begin
            this.borrowSemaphoreSize = (maxActive > 1) ? Math.min(maxActive / 2, NCPUS) : 1;
            //fix issue:#19 Chris-2020-08-16 end
        }
    }

    public int getBorrowSemaphoreSize() {
        return borrowSemaphoreSize;
    }

    public void setBorrowSemaphoreSize(int borrowSemaphoreSize) {
        if (borrowSemaphoreSize > 0) this.borrowSemaphoreSize = borrowSemaphoreSize;
    }

    public long getMaxWait() {
        return maxWait;
    }

    public void setMaxWait(long maxWait) {
        if (maxWait > 0) this.maxWait = maxWait;
    }

    public long getIdleTimeout() {
        return idleTimeout;
    }

    public void setIdleTimeout(long idleTimeout) {
        if (idleTimeout > 0) this.idleTimeout = idleTimeout;
    }

    public long getHoldTimeout() {
        return holdTimeout;
    }

    public void setHoldTimeout(long holdTimeout) {
        if (holdTimeout > 0) this.holdTimeout = holdTimeout;
    }

    public String getValidTestSql() {
        return validTestSql;
    }

    public void setValidTestSql(String validTestSql) {
        if (!isBlank(validTestSql)) this.validTestSql = trimString(validTestSql);
    }

    public int getValidTestTimeout() {
        return validTestTimeout;
    }

    public void setValidTestTimeout(int validTestTimeout) {
        if (validTestTimeout >= 0) this.validTestTimeout = validTestTimeout;
    }

    public long getValidAssumeTime() {
        return validAssumeTime;
    }

    public void setValidAssumeTime(long validAssumeTime) {
        if (validAssumeTime >= 0) this.validAssumeTime = validAssumeTime;
    }

    public long getTimerCheckInterval() {
        return timerCheckInterval;
    }

    public void setTimerCheckInterval(long timerCheckInterval) {
        if (timerCheckInterval > 0) this.timerCheckInterval = timerCheckInterval;
    }

    public boolean isForceCloseUsingOnClear() {
        return forceCloseUsingOnClear;
    }

    public void setForceCloseUsingOnClear(boolean forceCloseUsingOnClear) {
        this.forceCloseUsingOnClear = forceCloseUsingOnClear;
    }

    public long getDelayTimeForNextClear() {
        return delayTimeForNextClear;
    }

    public void setDelayTimeForNextClear(long delayTimeForNextClear) {
        if (delayTimeForNextClear > 0) this.delayTimeForNextClear = delayTimeForNextClear;
    }

    public String getPoolImplementClassName() {
        return poolImplementClassName;
    }

    public void setPoolImplementClassName(String poolImplementClassName) {
        this.poolImplementClassName = trimString(poolImplementClassName);
    }

    public boolean isEnableJmx() {
        return enableJmx;
    }

    public void setEnableJmx(boolean enableJmx) {
        this.enableJmx = enableJmx;
    }

    public void setPrintConfigInfo(boolean printConfigInfo) {
        this.printConfigInfo = printConfigInfo;
    }

    public boolean isPrintRuntimeLog() {
        return printRuntimeLog;
    }

    public void setPrintRuntimeLog(boolean printRuntimeLog) {
        this.printRuntimeLog = printRuntimeLog;
    }

    //***************************************************************************************************************//
    //                                     4: connection default value set methods(12)                               //
    //***************************************************************************************************************//
    public String getDefaultCatalog() {
        return defaultCatalog;
    }

    public void setDefaultCatalog(String defaultCatalog) {
        this.defaultCatalog = trimString(defaultCatalog);
    }

    public String getDefaultSchema() {
        return defaultSchema;
    }

    public void setDefaultSchema(String defaultSchema) {
        this.defaultSchema = trimString(defaultSchema);
    }

    public Boolean isDefaultReadOnly() {
        return defaultReadOnly;
    }

    public void setDefaultReadOnly(Boolean defaultReadOnly) {
        this.defaultReadOnly = defaultReadOnly;
    }

    public Boolean isDefaultAutoCommit() {
        return defaultAutoCommit;
    }

    public void setDefaultAutoCommit(Boolean defaultAutoCommit) {
        this.defaultAutoCommit = defaultAutoCommit;
    }

    public Integer getDefaultTransactionIsolationCode() {
        return defaultTransactionIsolationCode;
    }

    public void setDefaultTransactionIsolationCode(Integer transactionIsolationCode) {
        String transactionIsolationName = TransactionIsolationLevel.getTransactionIsolationName(transactionIsolationCode);
        if (!isBlank(transactionIsolationName)) {
            this.defaultTransactionIsolationCode = transactionIsolationCode;
            this.defaultTransactionIsolationName = transactionIsolationName;
        } else {
            throw new BeeDataSourceConfigException("Invalid isolation code:" + transactionIsolationCode);
        }
    }

    public String getDefaultTransactionIsolationName() {
        return defaultTransactionIsolationName;
    }

    public void setDefaultTransactionIsolationName(String transactionIsolationName) {
        transactionIsolationName = trimString(transactionIsolationName);
        defaultTransactionIsolationCode = TransactionIsolationLevel.getTransactionIsolationCode(transactionIsolationName);
        if (defaultTransactionIsolationCode != null) {
            this.defaultTransactionIsolationName = transactionIsolationName;
        } else {
            throw new BeeDataSourceConfigException("Invalid transaction isolation name:" + transactionIsolationName + ", value is one of[" + TRANS_LEVEL_CODE_LIST + "]");
        }
    }

    //***************************************************************************************************************//
    //                                    5: connection factory class set methods(12)                               //
    //***************************************************************************************************************//
    public Object getConnectionFactory() {
        return connectionFactory;
    }

    public Class getConnectionFactoryClass() {
        return connectionFactoryClass;
    }

    public void setConnectionFactoryClass(Class connectionFactoryClass) {
        this.connectionFactoryClass = connectionFactoryClass;
    }

    public String getConnectionFactoryClassName() {
        return connectionFactoryClassName;
    }

    public void setConnectionFactoryClassName(String connectionFactoryClassName) {
        this.connectionFactoryClassName = trimString(connectionFactoryClassName);
    }

    public Class getPasswordDecoderClass() {
        return passwordDecoderClass;
    }

    public void setPasswordDecoderClass(Class passwordDecoderClass) {
        this.passwordDecoderClass = passwordDecoderClass;
    }

    public String getPasswordDecoderClassName() {
        return passwordDecoderClassName;
    }

    public void setPasswordDecoderClassName(String passwordDecoderClassName) {
        this.passwordDecoderClassName = passwordDecoderClassName;
    }

    public void removeConnectProperty(String key) {
        if (!isBlank(key)) connectProperties.remove(key);
    }

    public void addConnectProperty(String key, Object value) {
        if (!isBlank(key) && value != null) connectProperties.put(key, value);
    }

    public void addConnectProperty(String connectPropertyText) {
        if (!isBlank(connectPropertyText)) {
            for (String attribute : connectPropertyText.split("&")) {
                String[] pair = attribute.split("=");
                if (pair.length == 2) {
                    addConnectProperty(pair[0].trim(), pair[1].trim());
                } else {
                    pair = attribute.split(":");
                    if (pair.length == 2) {
                        addConnectProperty(pair[0].trim(), pair[1].trim());
                    }
                }
            }
        }
    }


    //***************************************************************************************************************//
    //                                     6: configuration load from properties load (3)                                                     //
    //***************************************************************************************************************//
    public void loadFromPropertiesFile(String filename) {
        if (isBlank(filename)) throw new IllegalArgumentException("Properties file can't be null");
        loadFromPropertiesFile(new File(filename));
    }

    public void loadFromPropertiesFile(File file) {
        if (file == null) throw new IllegalArgumentException("Properties file can't be null");
        if (!file.exists()) throw new IllegalArgumentException("File not found:" + file.getAbsolutePath());
        if (!file.isFile()) throw new IllegalArgumentException("Target object is not a valid file");
        if (!file.getAbsolutePath().toLowerCase(Locale.US).endsWith(".properties"))
            throw new IllegalArgumentException("Target file is not a properties file");

        InputStream stream = null;
        try {
            stream = new FileInputStream(file);
            Properties configProperties = new Properties();
            configProperties.load(stream);
            loadFromProperties(configProperties);
        } catch (BeeDataSourceConfigException e) {
            throw e;
        } catch (Throwable e) {
            throw new BeeDataSourceConfigException("Failed to load properties file", e);
        } finally {
            if (stream != null) try {
                stream.close();
            } catch (Throwable e) {
                CommonLog.warn("Failed to close properties file inputStream,cause:", e);
            }
        }
    }

    public void loadFromProperties(Properties configProperties) {
        if (configProperties == null || configProperties.isEmpty())
            throw new BeeDataSourceConfigException("Properties can't be null or empty");

        //1:load configuration item values from outside properties
        Map<String, Object> setValueMap = new HashMap<String, Object>(configProperties.size());
        for (String propertyName : configProperties.stringPropertyNames()) {
            setValueMap.put(propertyName, configProperties.getProperty(propertyName));
        }

        //2:inject item value from map to this dataSource config object
        setPropertiesValue(this, setValueMap);

        //3:try to find 'connectProperties' config value and put to ds config object
        addConnectProperty(getPropertyValue(configProperties, "connectProperties"));
        String connectPropertiesCount = getPropertyValue(configProperties, "connectProperties.count");
        if (!isBlank(connectPropertiesCount)) {
            int count = Integer.parseInt(connectPropertiesCount.trim());
            for (int i = 1; i <= count; i++)
                addConnectProperty(getPropertyValue(configProperties, "connectProperties." + i));
        }
    }

    //***************************************************************************************************************//
    //                                    7: configuration check and connection factory create methods(4)            //
    //***************************************************************************************************************//
    //check pool configuration
    public BeeDataSourceConfig check() throws SQLException {
        if (this.maxActive <= 0)
            throw new BeeDataSourceConfigException("maxActive must be greater than zero");
        if (this.initialSize < 0)
            throw new BeeDataSourceConfigException("initialSize must not be less than zero");
        if (this.initialSize > maxActive)
            throw new BeeDataSourceConfigException("initialSize must not be greater than maxActive");
        if (this.borrowSemaphoreSize <= 0)
            throw new BeeDataSourceConfigException("borrowSemaphoreSize must be greater than zero");
        //fix issue:#19 Chris-2020-08-16 begin
        //if (this.borrowConcurrentSize > maxActive)
        //throw new BeeDataSourceConfigException("Pool 'borrowConcurrentSize' must not be greater than pool max size");
        //fix issue:#19 Chris-2020-08-16 end
        if (this.idleTimeout <= 0)
            throw new BeeDataSourceConfigException("idleTimeout must be greater than zero");
        if (this.holdTimeout <= 0)
            throw new BeeDataSourceConfigException("holdTimeout must be greater than zero");
        if (this.maxWait <= 0)
            throw new BeeDataSourceConfigException("maxWait must be greater than zero");
        //fix issue:#1 The check of validationQuerySQL has logic problem. Chris-2019-05-01 begin
        //if (this.validationQuerySQL != null && validationQuerySQL.trim().length() == 0) {
        if (isBlank(this.validTestSql))
            throw new BeeDataSourceConfigException("validTestSql cant be null or empty");
        if (!this.validTestSql.toUpperCase(Locale.US).startsWith("SELECT ")) {
            //fix issue:#1 The check of validationQuerySQL has logic problem. Chris-2019-05-01 end
            throw new BeeDataSourceConfigException("validTestSql must be start with 'select '");
        }

        this.connectionFactory = this.createConnectionFactory();
        if (isBlank(this.poolName)) this.poolName = "FastPool-" + PoolNameIndex.getAndIncrement();

        BeeDataSourceConfig configCopy = new BeeDataSourceConfig();
        this.copyTo(configCopy);
        return configCopy;
    }

    //copy configuration to other object
    void copyTo(BeeDataSourceConfig config) {
        //1:primitive type copy
        String fieldName = "";
        try {
            for (Field field : BeeDataSourceConfig.class.getDeclaredFields()) {
                if (Modifier.isFinal(field.getModifiers()) || Modifier.isStatic(field.getModifiers()) || "connectProperties".equals(field.getName()))
                    continue;

                fieldName = field.getName();
                Object fieldValue = field.get(this);
                if (printConfigInfo) CommonLog.info("{}.{}={}", poolName, fieldName, fieldValue);
                field.set(config, fieldValue);
            }
        } catch (Exception e) {
            throw new BeeDataSourceConfigException("Failed to copy field[" + fieldName + "]", e);
        }

        //2:copy 'connectProperties'
        for (Map.Entry<String, Object> entry : connectProperties.entrySet()) {
            if (printConfigInfo)
                CommonLog.info("{}.connectProperties.{}={}", poolName, entry.getKey(), entry.getValue());
            config.addConnectProperty(entry.getKey(), entry.getValue());
        }
    }

    //create PasswordDecoder instance
    private PasswordDecoder createPasswordDecoder() throws BeeDataSourceConfigException {
        PasswordDecoder passwordDecoder = null;
        Class<?> passwordDecoderClass = this.passwordDecoderClass;
        if (passwordDecoderClass == null && !isBlank(passwordDecoderClassName)) {
            try {
                passwordDecoderClass = Class.forName(passwordDecoderClassName);
            } catch (Throwable e) {
                throw new BeeDataSourceConfigException("Failed to load password decoder class:" + passwordDecoderClassName, e);
            }
        }

        if (passwordDecoderClass != null) {
            String errorMsg = checkClass(passwordDecoderClass, PasswordDecoder.class, "password decoder");
            if (!isBlank(errorMsg)) throw new BeeDataSourceConfigException(errorMsg);

            try {
                passwordDecoder = (PasswordDecoder) passwordDecoderClass.newInstance();
            } catch (Throwable e) {
                throw new BeeDataSourceConfigException("Failed to instantiate password decoder class:" + passwordDecoderClass.getName(), e);
            }
        }
        return passwordDecoder;
    }

    //create Connection factory
    private Object createConnectionFactory() throws BeeDataSourceConfigException, SQLException {
        PasswordDecoder passwordDecoder = createPasswordDecoder();
        if (connectionFactoryClass == null && isBlank(connectionFactoryClassName)) {
            if (isBlank(jdbcUrl)) throw new BeeDataSourceConfigException("jdbcUrl can't be null");

            Driver connectDriver = null;
            if (!isBlank(driverClassName))
                connectDriver = loadDriver(driverClassName);
            else if (!isBlank(jdbcUrl))
                connectDriver = DriverManager.getDriver(jdbcUrl);
            if (connectDriver == null)
                throw new BeeDataSourceConfigException("Failed to load driver:" + driverClassName);
            if (!connectDriver.acceptsURL(jdbcUrl))
                throw new BeeDataSourceConfigException("jdbcUrl(" + jdbcUrl + ")can not match driver:" + connectDriver.getClass().getName());

            Properties configProperties = new Properties();
            configProperties.putAll(this.connectProperties);//copy
            if (!isBlank(username) && !configProperties.containsKey("user"))//set username
                configProperties.setProperty("user", username);

            String tempPassword = configProperties.getProperty("password");
            if (isBlank(tempPassword)) tempPassword = password;
            if (!isBlank(tempPassword)) {//set password
                if (passwordDecoder != null) tempPassword = passwordDecoder.decode(tempPassword);
                configProperties.setProperty("password", tempPassword);
            }
            return new ConnectionFactoryByDriver(jdbcUrl, connectDriver, configProperties);
        } else {
            try {
                //1:load connection factory by class name
                Class<?> conFactClass = connectionFactoryClass != null ? connectionFactoryClass : Class.forName(connectionFactoryClassName);

                //2: check connection factory class
                Class[] parentClasses = new Class[]{RawConnectionFactory.class, RawXaConnectionFactory.class, DataSource.class, XADataSource.class};
                String errorMsg = checkClass(conFactClass, parentClasses, "connection factory");
                if (!isBlank(errorMsg)) throw new BeeDataSourceConfigException(errorMsg);

                //3:create connection factory instance
                Object factory = conFactClass.newInstance();

                //4:copy properties to value map(inject to dataSource or factory)
                Map<String, Object> propertyValueMap = new HashMap<String, Object>(connectProperties);//copy

                //5:set set username,password,jdbc-url to value map
                if (!isBlank(username) && !propertyValueMap.containsKey("user"))//set username
                    propertyValueMap.put("user", username);

                Object passwordPropVal = propertyValueMap.get("password");
                String tempPassword = passwordPropVal instanceof String ? (String) passwordPropVal : null;
                if (isBlank(tempPassword)) tempPassword = password;
                if (!isBlank(tempPassword)) {//set password
                    if (passwordDecoder != null) tempPassword = passwordDecoder.decode(tempPassword);
                    propertyValueMap.put("password", tempPassword);
                }

                if (!isBlank(jdbcUrl)) {//set jdbc url
                    if (!propertyValueMap.containsKey("url")) propertyValueMap.put("url", jdbcUrl);
                    if (!propertyValueMap.containsKey("URL")) propertyValueMap.put("URL", jdbcUrl);
                    if (!propertyValueMap.containsKey("jdbcUrl")) propertyValueMap.put("jdbcUrl", jdbcUrl);
                }

                //6:inject properties to connection factory or dataSource
                setPropertiesValue(factory, propertyValueMap);

                //7:return RawConnectionFactory or RawXaConnectionFactory
                if (factory instanceof RawConnectionFactory || factory instanceof RawXaConnectionFactory) {
                    return factory;
                } else if (factory instanceof XADataSource) {
                    return new XaConnectionFactoryByDs((XADataSource) factory, username, password);
                } else if (factory instanceof DataSource) {
                    return new ConnectionFactoryByDs((DataSource) factory, username, password);
                } else {
                    throw new BeeDataSourceConfigException("Error connection factory type:" + connectionFactoryClassName);
                }
            } catch (ClassNotFoundException e) {
                throw new BeeDataSourceConfigException("Not found connection factory class:" + connectionFactoryClassName, e);
            } catch (InstantiationException e) {
                throw new BeeDataSourceConfigException("Failed to instantiate connection factory class:" + connectionFactoryClassName, e);
            } catch (IllegalAccessException e) {
                throw new BeeDataSourceConfigException("Failed to instantiate connection factory class:" + connectionFactoryClassName, e);
            }
        }
    }
}

